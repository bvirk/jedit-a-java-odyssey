/* :tabSize=4:indentSize=4:noTabs=false:
 * :folding=explicit:collapseFolds=1: 
The folding style is important for lookup facility of macro startup */ 

import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.nio.file.Files;
import java.nio.charset.Charset;

nulSA = new String[]{};


//{{{ String sDir()
/**
 * gets jEdit SettingsDirectory
 *
 * @return Jedit SettingsDirectory
 */
String sDir() {
	return jEdit.getSettingsDirectory();
} //}}}

//{{{ String ux(String possibleBackslashed)
/**
 * Needed multiplatform workarounds prior certain regex manipulations
 *
 * @param possibleBackslashed path (windows)
 * @return forward slashed path
 */
String ux(String possibleBackslashed) { 
	return possibleBackslashed.replaceAll("\\\\","/"); 
} //}}}

//{{{ String capitalized(String s)
/**
 * Capitalize a string. That means make the first character uppercase.
 *
 * @param s gets capitalized. s shall be of String or StringBuilder or any, 'has substring that returns a toString() able object, type.
 * @return capitalized string
 */
String capitalized(Object s) {
    return ""+s.substring(0,1).toUpperCase()+s.substring(1);
} //}}}

//{{{ String[] toArray(Object toArrayAble)
/**
 * Shortcut for toArrayAble.toArray(String[]), where toArrayAble is a container instance implementing Collection 
 *  
 * @param any toArrayAble container eg. ArrayList
 * @return String[] array
 */
String[] toArray(Object toArrayAble) {
    return toArrayAble.toArray(new String[toArrayAble.size()]);
} //}}}

//{{{ String[] withInsertion(String[] list, String newCome, int insertIndex)
/**
 * Inserts a string in an array of strings
 *
 * @param list array of string
 * @param newCome string to be inserted
 * @param insertIndex where string is inserted
 * @return array of strings with the inserted string
 */
String[] withInsertion(String[] list, String newCome, int insertIndex) {
    String [] newList = new String[list.length+1];
    for (int i,spread; i<=list.length;i++) 
        newList[i] = i == insertIndex 
            ? newCome.substring(spread++)
            : list[i-spread];
    return newList;
} //}}}

//{{{ interface List asList(String i1, ...)
/**
 * Beanshells absence of varargs motivated shortcut for Arrays.asList( ...
 *
 * @param ix is list items of type String
 * @return List
 */
List asList(String i1) {
	return Arrays.asList(new String[]{i1});
}
List asList(String i1,String i2) {
	return Arrays.asList(new String[]{i1,i2});
} 
List asList(String i1,String i2,String i3) {
	return Arrays.asList(new String[]{i1,i2,i3});
} 
List asList(String i1,String i2,String i3,String i4) {
	return Arrays.asList(new String[]{i1,i2,i3,i4});
} 
List asList(String i1,String i2,String i3,String i4,String i5) {
	return Arrays.asList(new String[]{i1,i2,i3,i4,i5});
} //}}}

List assList(Object i1,Object i2) {
	return new ArrayList(Arrays.asList(new Object[]{i1,i2}));
}

//{{{ String mEval(String expressionList)
/**
 * Convenient avoidance of 'Math' prefixing matematically functions, and build expression as serie af expression of which the value of rightmost 
 * is returned. An example illustates:
 *
 * A spot, with a beam angle of 36 degreese is places 1.3 meter above a table. What is the diameter of the beam at table? 
 * mEval("angle=36;height=1.3;2*height*tan(pi*angle/2/180)")
 *
 * @param semicolon delimited lists of numeric expressions or assigments. Space isn't allowed
 * @return value of rightmost expression
 */
String mEval(String exp) {
	return ""+BeanShell.eval(jEdit.getActiveView(),BeanShell.getNameSpace(),
		exp.replaceAll("(tan|cos|sin|sqrt|atan|acos|asin|sqrt|pow|exp|log)\\(","Math.$1(").replaceAll("(?i)PI","Math.PI"));
} //}}}

//{{{ String dkCapUnCameled(String aTxt)
/**
 * Capitalize, decodes camelcase or space and substitute danish letters.
 * The danish letters is coded by escape substitution using dot
 *
 * .AE .OE .AA for   Æ,Ø and Å
 * .ae .oe .aa for   æ,ø and å   
 * 
 * for words, starting with some of above, a coded leading space is coded like a uppercase of above.
 *
 * eg. "str.aalendeMed.OElledr.oedOg.AEbler." becomes
 *
 * Strålende med ølledrød og æbler.
 *
 * @param aTxt with lower camelcase substitution of space between words 
 * @return Capitalized, un camelcased string 
 */
String dkCapUnCameled(String aTxt) {
    StringBuilder txt= new StringBuilder(aTxt);
    final String [][] natCodes = {{"Æ","AE"},{"Ø","OE"},{"Å","AA"},{"æ","ae"},{"ø","oe"},{"å","aa"}};   
    int digInRow;
    for (int startPos=0; startPos < txt.length()-1; startPos++) {
        char chr = txt.charAt(startPos);
        digInRow = Character.isDigit(chr) ? digInRow +1 : (digInRow > 0 ? (Character.isLetter(chr) ? -1 : 0 ) : 0); 
        if (chr == '.') {
            for (int i=0; i<6 ;i++)  
                if (txt.substring(startPos+1,startPos+3).equals(natCodes[i][1])) {
                    txt.delete(startPos,startPos+3);
                    txt.insert(startPos,natCodes[i][0]);
                    startPos--;
                    break;
                }
        } else 
            if (Character.isUpperCase(chr) || (digInRow == 1 || digInRow == -1)) {
                txt.insert(startPos,' ');
                txt.setCharAt(startPos+1,Character.toLowerCase(chr));
                startPos++;
            }
    }
    return capitalized(txt);
} //}}}

//{{{ interface List readAllLines(File file, boolean supressIOException)
/**
 * Iterabel, comparable, toArrayAble, random accessible list of utf-8 encoded file lines
 *
 * @param file to read from
 * @return List of utf-8 encoded lines of file or an empty list on IO. If supressIOException
 * is true a thrown IOException has the consequence of readLines returning an empty List.
 */
List readAllLines(File file, boolean supressIOException) {
	List retval;
	try {
		retval = Files.readAllLines(file.toPath(),Charset.forName("UTF-8"));
	} catch(IOException e) {
		if (supressIOException) 
			retval = new ArrayList();
		else
			throw e;
	}
	return retval;
} //}}}

//{{{ List readAllLines(File file)
/**
 * Iterabel, comparable, toArrayAble, random accessible list of utf-8 encoded file lines
 *
 * @param file to read from
 * @return List of utf-8 encoded lines of file or empty list on IOException.
 */
List readAllLines(File file) {
	return readAllLines(file,true);
} //}}}

//{{{ interface List readAllLines(String fileName)
/**
 * Iterabel, comparable, toArrayAble, random accessible list of utf-8 encoded file lines
 *
 * @param file name of file to read from
 * @return  List of utf-8 encoded lines of file
 */
List readAllLines(String fileN) {
	return readAllLines(new File(fileN),false);
} //}}}

//{{{ interface List  fileLines(String fileName, String startPattern, String endPattern)
/**
 * Lines of pattern delimited block. The pattern lines is not inclusive the block 
 *
 * @param fileName with lines
 * @param startPattern matches the line before returned line 0
 * @param endPattern matches the line after last line in returned list
 * @return lines in pattern delimited block
 */
List  fileLines(String fileName, String startPattern, String endPattern) {
	return Beam(Files.lines(new File(fileName).toPath()))
		.filter(false,"item-> {"+
			"if ( arg1 == true )"+
			"    return item.matches(´"+endPattern+"´)  ? (arg1=false) : true;"+
			"arg1 = item.matches(´"+startPattern+"´);"+
			"return false; }")
		.toList();	
} //}}}

//{{{ String fileLinesString(String fileName, String blockName)
/**
 * Return block of lines, surrounded by the lines
 *
 *  /***blockName
 *		and
 * 	***/
/**
 * Where blockName above is replaced with the actual parameter.
 *
 * @param fileName with Lines
 * @param blockName is what identifies the block
 * @return lines as a string 
 */
String fileLinesString(String fileName, String blockId) {
    return String.join("\n",toArray(fileLines(fileName,blockId)));
} //}}}

//{{{ String fileLinesString(String fileName, String blockId, Object [] parms, Properties cssProp)
/**
 * java.text.MessageFormat parameterizeable version of fileLines(String fileName, String blockName)
 *
 * @param fileName with Lines
 * @param blockId is what identifies the block
 * @param parms is an array of objects, referenced by their curly brace surrounding parameter number in one or more lines.
 * @return lines as a string
 */
String fileLinesString(String fileName, String blockId, Object [] parms, Properties cssProp) {
    StringBuilder lines = new StringBuilder();
    boolean inScript;
    for (String line : fileLines(fileName,blockId)) {
    	if (inScript) {
    		if (line.trim().equals("</script>")) {
    			inScript=false;
    		}
    		lines.append(line).append("\n");
    	} else {
    		if (line.trim().equals("<script>"))
    			inScript=true;
    		lines.append(java.text.MessageFormat.format(line,parms)).append("\n");
    	}
    }
    return classToStyle(lines.toString(),cssProp);
} //}}}

//{{{ String fileLinesString(String fileName, String blockId, Object [] parms)
/**
 * java.text.MessageFormat parameterizeable version of fileLines(String fileName, String blockName)
 *
 * @param fileName with Lines
 * @param blockId is what identifies the block
 * @param parms is an array of objects, referenced by their curly brace surrounding parameter number in one or more lines.
 * @return lines as a string
 */
String fileLinesString(String fileName, String blockId, Object [] parms) {
    StringBuilder lines = new StringBuilder();
    boolean inScript;
    for (String line : fileLines(fileName,blockId)) {
    	if (inScript) {
    		if (line.trim().equals("</script>")) {
    			inScript=false;
    		}
    		lines.append(line).append("\n");
    	} else {
    		if (line.trim().equals("<script>"))
    			inScript=true;
    		lines.append(java.text.MessageFormat.format(line,parms)).append("\n");
    	}
    }
    return lines.toString();
} //}}}

//{{{ interface fileLines(String fileName, String blockId)
/**
 * Lines of pattern delimited block. The pattern lines is not inclusive the block 
 *
 * @param fileName with lines
 * @param blockId forms parameter startPattern for calling fileLines(String fileName, String startPattern, String endPattern) 
 * @return lines in pattern delimited block
 */
List fileLines(String fileName, String blockId) {
	return fileLines(fileName,"/\\*\\*\\*"+blockId,"\\s*\\*\\*\\*/");
} //}}}

//{{{ String fileLinesString(String fileName, String blockId, Properties cssProp)
/**
 * Replaces class attributes with style attributes in addition to fileLinesString(String fileName, String blockId
 *
 * @param fileName with lines
 * @param blockId is what identifies the block
 * @param cssProp that holds the css properties of class attribute values, if not found a style="" vould be the replacement result.
 * @return lines as a string 
 */
String fileLinesString(String fileName, String blockId, Properties cssProp) {
    return classToStyle(fileLinesString(fileName,blockId),cssProp);
} //}}}

//{{{ String classToStyle(String htmlWithClassAttributes, Properties cssProp) 
/**
 * Transforms class attributes to style attribute using stylesheet as properties
 *
 * @param htmlWithClassAttributes is input with class attributes
 * @param cssProp is ths stylesheet as a property list - keys are classNames
 * @return the converted string containing style attributes
 */
String classToStyle(String htmlWithClassAttributes, Properties cssProp) {
	String html = htmlWithClassAttributes;
	
	Pattern pat = Pattern.compile("class=\"([^\"]+)\"");
    Matcher m = pat.matcher(html);
    while (m.find()) {
		html = html.substring(0,m.start(1)-7)+ "style=\"" + cssProp.getProperty(m.group(1),"") +html.substring(m.end(1));
		m =	pat.matcher(html);
	} 
	return html;
} //}}}

//{{{ Properties cssAsProperties(String fileName) 
/**
 * Represent, in a simple way, cacsading style sheet block as properties. It is only the trimmed, with dot removed, selector,
 * that becomes the key and {, } and whitespace besides a single space is removed from value. 
 * It is only meant to be used to replace class attributes with style attributes - a single class selector for each property.
 *   
 *   .bottomline {
 *   	text-align:center; 
 *   	vertical-align: bottom;
 *   	font-weight: bold;
 *   	font-size: 0.8em;
 *   }     
 *  
/**  
 *  Has property:  'bottomline' with value  'text-align:center; vertical-align: bottom; font-weight: bold; font-size: 0.8em;'
 *
 * @param fileName of file to find block css
 * @return css  
 */
Properties cssAsProperties(String fileName) {
    Properties prop = new Properties();
    for (String k_curly_v : String.join("\n",toArray(readAllLines(fileName)))
    			.replaceAll("\\n","").replaceAll("\\t"," ").replaceAll(" {2,}"," ").replaceAll("} *$","").split("}")) {
        String [] kv = k_curly_v.split("\\{");
        prop.setProperty(kv[0].replace(".","").trim(),kv[1].trim());
    }
    return prop;
} //}}}

//{{{ interface List startupBeanshellFilesLines()
/**
 * All lines in  jEdit settings directory startup directory files
 *
 * @return List of lines in all jEdit settings directory startup directory files 
 */
public List startupBeanshellFilesLines() {
	List lines;
	for (File f : new File(sDir()+"/startup").listFiles())
		if (null==lines) 
			lines = readAllLines(f);
		else
			lines.addAll(readAllLines(f));
	return lines;
} //}}}

//{{{ void saveAllStartupFiles(View view)
/**
 * saves all dirty files in jeditSettings/startup
 *
 * @param view context
 */
boolean saveAllStartupFiles(View view) {
	boolean wasDirty;
	for (Buffer b: jEdit.getBuffers()) 
		if (ux(b.getPath()).startsWith(sDir()+"/startup/"))
			if(b.isDirty()) {
				wasDirty=true;
				while(!b.save(view,null));
			}
	return wasDirty;
} //}}}

//{{{ void toFile(String fileName,thing) 
/**
 * Things being possible an array or iterable saved as file in charset utf-8
 *
 * @param fileName to hold thing
 * @param thing to be saved as file in line broken toString() occurrence
 */
void toFile(String fileName,Object thing) {
	toFile(fileName,thing,null);
} //}}}

//{{{ void toFile(String fileName,Object thing,Object filter) 
/**
 * Things being possible an array or iterable, converted saved as a file in charset utf-8
 *
 * @param fileName to hold thing
 * @param thing to be saved as file in line broken toString() occurrence
 * @param filter to transfer each line to something
 */
void toFile(String fileName,Object thing,Object function) {
	OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(fileName),"utf-8"); 
	if (thing.getClass().isArray() || thing instanceof AbstractCollection )
		for (Object line : thing)
			osw.write(""+(null==function ? line : function.apply(line))+"\n");
	else osw.write(""+(null==function ? thing : function.apply(thing)));
	osw.close();
} //}}}

//{{{ void appendToFile(String fileName, List lines)
/**
 *	Appends lines to file, charset utf-8
 *
 * @param fileName of file to which lines are appended
 * @param lines to be appended
 */
void appendToFile(String fileName, List lines) {
	List oldLines = readAllLines(new File(fileName),true);
	oldLines.addAll(lines);
	toFile(fileName,oldLines);
} //}}}

//{{{ interface List jimport(String className)

// OS: Linux | Windows 
/**
 * Get package name of class. It is used for two purposes.
 *  1. Insertion of import declaration
 *  2. Getting api help from Oracle's api documentation
 *
 * It uses an extern script, 'jimport' or 'jimport.bat'
 * A prioritized list of jars can be searched - shown below facilitates jedit plugin development
 * The script shall be reachable from a system shell - being in system environment PATH.
 *
 * NOTE (for the uninitiated and forgetful)
 * on linux, chmod +x jimport
 * on windows, grep and tr from unxutils required (or their equals - test!)
 */ 
 // Linux - (change jeditSettings or perhaps other directories)
 
 // | #!/bin/bash
 // | if [ -z $1 ]; then
 // |	exit 2
 // | fi
 // | echoImport() { 
 // | 	if [ -f $2 ];then
 // | 		class=`jar -tf $2|grep /${1}.class`
 // | 		if [ -n "${class}" ];then
 // | 			jarFile=${2##*/}
 // | 			echo ${jarFile%.*}:${class}
 // | 		fi
 // | 			return 0
 // | 	fi
 // | }
 // | 
 // | jeditSettings=/home/bvirk/.jedit
 // | 
 // | echoImport $1 /usr/lib/java/jre/lib/rt.jar
 // | echoImport $1 /usr/local/share/jEdit/5.5.0/jedit.jar
 // | # echoImport $1 ${jeditSettings}/jars/TxtConvPlugin.jar
 // | # echoImport $1 ${jeditSettings}/jars/txtmark.jar
 // | # echoImport $1 ${jeditSettings}/jars/jsoup-1.11.3.jar 
 
 
 
 
 
 
 // Windows with unxUtils installed (grep tr), .bat file
 
 // | @echo off
 // | if n%1==n exit 2
 // | setlocal
 // | goto main
 // | 
 // | :invokejar
 // | if not exist %1 exit /b 1
 // | FOR /F "usebackq tokens=*" %%b IN (`jar -tf %1 ^|grep /%2.class ^|tr -s "\r\n" " "`) DO set classes=%%b
 // | IF NOT "%classes%"=="" ( 
 // | 	echo %~n1:%classes%
 // | 	set classes=
 // | )
 // | exit /b 0                                    
 // | 
 // | 
 // | :main
 // | if n%1==n goto endofprogram
 // | call :invokejar C:\Programmer\java\jdk1.8.0\jre\lib\rt.jar %1
 // | call :invokejar C:\Programmer\jEdit\jedit.jar %1
 // | rem call :invokejar D:\home\dev\APPLIC~1\jEdit\jars\TxtConvPlugin.jar %1
 // | rem call :invokejar D:\home\dev\APPLIC~1\jEdit\jars\txtmark.jar %1
 // | rem call :invokejar D:\home\dev\APPLIC~1\jEdit\jars\jsoup-1.11.3.jar %1
 // | 
 // | :endofProgram
 // | endlocal
 
/**
 * @param onlyOracle limits returned packages for those in rt.jar
 * @param className 
 * @return package name of class
 */
List jimport(String className) {
	List classes = new ArrayList();
	int scriptIsMissingRetval() {
		return OperatingSystem.isUnix() ?  127 : 1;
	}
	if(OperatingSystem.isUnix() ||OperatingSystem.isWindows() ) {
		String[] cmds = {
			OperatingSystem.isUnix()
				? "/bin/bash"
				:"cmd.exe" 
			,OperatingSystem.isUnix()
				?"-c"
				: "/c"
			,"jimport "+className};
		Process proc = Runtime.getRuntime().exec(cmds); 
		BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		while ((line = br.readLine()) != null) {
			String[] jarPacks = line.split(":");
				for (String s: jarPacks[1].split(" "))
					classes.add(jarPacks[0]+":"+s);
		}
		br.close();
		int retval;
		try {
			proc.waitFor();
		} catch (InterruptedException e ) {
			retval=scriptMissingRetval();
		}	
		if (retval == 0)
			retval = proc.exitValue();
		if (retval == scriptIsMissingRetval())
			classes.add("scriptNotFound: ");
		return classes;
	}
} //}}}

//{{{ String elSubst(String input,Properties properties) 
/**
 * el for the 'JSP Expression Language' - function elSubst replaces ${foo} in "some ${foo} thing" with the value of foo in some properties 
 * It's a string substitution princip also used in Apache ant build files.
 * This simple implementation below makes ${}whatever} to ${whatever} without dereferencing to any property value. 
 *
 * @param properties used to look values
 * @param input string
 * @return String being EL substituted
 */
String elSubst(String input,Properties properties) {
	Pattern pat = Pattern.compile("\\$\\{([^}]+)\\}");
	Matcher m = pat.matcher(input);
	while (m.find()) {
		input = input.substring(0,m.start(1)-2)+ properties.getProperty(m.group(1),"${}"+m.group(1)+"}") +input.substring(m.end(1)+1);
		m =	pat.matcher(input);
	}
	return input.replaceAll("\\$\\{\\}([^}]+)\\}","\\${$1}");
} //}}}

//{{{ XThis UniProp(String fileName, String startPattern, String endPattern) 
/**
 * Reads properties from startpattern/endpattern lines delimited block in file. Return a Properties like object which getProperty/setProperty 
 * methods gives indirect access to jEdit properties. Eg. if a value is ${jedit.<jedit property>}, where <jedit property>, should 
 * be read as a placeholder for a jedit property, it is the values of that Jedit property that is accessed. 
 * Note, too, the convenient mathingSortedKeys method.
 *
 * @param endPattern 
 * @param startPattern
 * @param fileName
 * @return org.gjt.sp.jedit.bsh.XThis object
 *
 */
org.gjt.sp.jedit.bsh.XThis UniProp(String fileName, String startPattern, String endPattern) {
	String getProperty(String key) {
		String val = prop.getProperty(key);
		if (val != null && val.matches("\\$\\{jedit\\.[^\\}]+}"))
			val = jEdit.getProperty(val.replaceAll("\\$\\{jedit\\.([^\\}]+)}","$1"));
		return val;
	}
 	void setProperty(String key,String val) {
 		String fval = prop.getProperty(key);
		if (fval != null && fval.matches("\\$\\{jedit\\.[^\\}]+}")) {
			jEdit.setProperty(fval.replaceAll("\\$\\{jedit\\.([^\\}]+)}","$1"),val);
		} else
			prop.setProperty(key,val); 
 	}
	List matchingSortedKeys(String regex) {
		ArrayList mk = new ArrayList();
		for (s : prop.keySet())
			if (s.matches(regex))
				mk.add(s);
		Collections.sort(mk);
		return mk;
	}
	Properties properties() { return prop; }
	Properties prop= new Properties();
	boolean inBlk=false;
	for (String line: readAllLines(fileName))
		if (inBlk)
			if (line.startsWith(endPattern))
				inBlk=false;
			else {
				String [] kv =line.trim().split("=");
				prop.setProperty(kv[0],kv[1]);
			}
		else
			if (line.startsWith(startPattern))
				inBlk=true;
	return this;
} //}}}

//{{{ interface List startsWithPropertyKeys(String startsWith,Properties prop) 
/**
 * startswith key filtered list of properties key=value strings 
 *
 * @param startsWith common leftmost part of set of property key
 * @param properties from which extracting those with common startswith keys
 * @return list of key=value strings
 */
List startsWithPropertyKeys(String startsWith,Properties prop) {
	List ar = new ArrayList();
	for (s:prop.stringPropertyNames())
		if (s.startsWith(startsWith))
			ar.add(s+"="+prop.getProperty(s));
	Collections.sort(ar);
	return ar;
} //}}}

//{{{ interface List jEditSWP(String startsWith)
/**
 * startswith key filtered list of jEdit properties key=value strings 
 *
 * @param startsWith common leftmost part of set of property key
 * @return list of key=value strings
 */
List jEditSWP(String startsWith) {
	return startsWithPropertyKeys(startsWith,jEdit.getProperties());
} //}}}

//{{{ void pop(String popn) 
/**
 * Descends into properties
 *
 * @param popn part of property name that starts after 'options.' 
 */
void pop(String popn) {
    List pl = jEditSWP("options."+popn);
    if (pl.size() == 1 ) {
        setClip(pl.get(0));
        p(pl.get(0));
        p("Copied to clipboard");
        return;
    }
    Map mKeys = new TreeMap();
    for ( String k :pl) {
        int dotI=k.indexOf(".",8+popn.length());
        int obLast = k.indexOf("=",9);
        if (dotI >-1 && dotI < obLast)
            obLast=dotI;
        mKeys.put(k.substring(8+popn.lastIndexOf("."),obLast),"");
    }
    StringBuffer m = new StringBuffer();
    int maxLineLength=80;
    int lineLength=0;
    for (String k : mKeys.keySet()) {
        m.append(k+" "+(lineLength>maxLineLength ? " \n" : " "));
        lineLength += lineLength>maxLineLength ? -lineLength : k.length();
    }
    p(m);
    
} //}}}

//{{{ interface List systemSWP(String startsWith)
/**
 * startswith key filtered list of system properties key=value strings 
 *
 * @param startsWith common leftmost part of set of property key
 * @return list of key=value strings
 */
List systemSWP(String startsWith) {
	return startsWithPropertyKeys(startsWith,System.getProperties());
} //}}}

//{{{ void foundStartupFunction(String funcName,View view)
/**
 * foundStartupFunction opens file containing startup function and position carret at folding heading
 * The function is identified by the commentline having the folding start pattern -
 * if this doesn't match exactly the function isn't found.
 * buffer gets locked - thus live with the inconvenient of unlocking and SOURCE IMMEDIATE! 
 * using macro startup - thus, without manually saving.
 *
 * Resourcing a startup functions reveals the difference between updating and
 defining - if the signature of a function is changed, two function exists 
 until next time jEdit is started. Just remember to change all places where
 function is used! in console use grep -nro in $JEDIT_SETTINGS and other *.bsh places
 * (unxUtils in path in windows)
 *
 * @param funcname without signature (return type, parentheses or arguments) 
 * @param view is 'predefined' view 
 * @return boolean true if function name is found
 */
boolean foundStartupFunction(String funcName,View view) {
	for (File f : new File(sDir()+"/startup").listFiles())
		if (String.join(" ",readAllLines(f.getPath())).matches(".+?//\\{\\{\\{ ([\\w\\[\\]]+\\s+?)+"+funcName+"\\(.+")) {
			if (jEdit.openFile(view, f.getPath()) != null) {
				Buffer buffer = view.getBuffer();
				if (!buffer.isLocked())
					buffer.toggleLocked(view);
				p(view.getBuffer().getName()); 
				jEdit.setBooleanProperty("search.hypersearch.toggle",false);
				jEdit.setBooleanProperty("search.keepDialog.toggle",false);
				org.gjt.sp.jedit.search.SearchAndReplace sap = new org.gjt.sp.jedit.search.SearchAndReplace(); 
				sap.setIgnoreCase(false);
				sap.setRegexp(true);
				sap.setAutoWrapAround(true);
				sap.setSearchString("//\\{\\{\\{ ([\\w\\[\\]]+\\s+?)+"+funcName+"\\(.+");
				sap.find(view);
			}
			return true;
		}
	return false; 
} //}}}

//{{{ TreeMap sourcedFuntions()
/**
 * List of function made available by running BeanShell.runScript with parameter ownNamespace beeing false as during startup 
 *
 * @return Treemap which (key,value) = (returntype methodname, ([method parameters,...]))
 */
TreeMap sourcedFuntions() {
	String simpleName(String className) {
		return className.matches(".+?\\[Ljava.+") 
			? "String[]" 
			:className.replaceAll("class ","").replaceAll("(\\w+\\.)+","");
	}
	TreeMap methods = new TreeMap();
	for (org.gjt.sp.jedit.bsh.BshMethod m:BeanShell.getNameSpace().getMethods()) {
		String parms="";
		if (m.getParameterTypes().length >0) {
			String [] parmA = new String[m.getParameterTypes().length];
			
			int i=0;
			for (Class claz: m.getParameterTypes())  {
				parmA[i++]= (claz==null? "uknown" : claz.getSimpleName());
			}
		
			i=0;
			for (s: m.getParameterNames())
				if (null != s && i < parmA.length) {
					parmA[i]=parmA[i] +" "+s;
					i++;
				}
			parms=String.join(",",parmA);
		}
		if (null != m.getReturnType())
			methods.put(simpleName(""+m.getReturnType())+" "+m.getName(),"("+parms+")");
	}
	return methods;
} //}}}

//{{{ String dateFormat(long unixtime, String format)
/**
 * wrapper around java.text.SimpleDateFormat
 *
 * @param unixtime milliseconds since the epoch (00:00:00 GMT, January 1, 1970)
 * @param format of SimpleDateFormat
 * @return String of date representation.
 */
String dateFormat(long unixtime, String format) {
	return new java.text.SimpleDateFormat(format).format(new Date(unixtime)).toString();
} //}}}

//{{{ interface List hasSuffixInOrBelow(String dir,String suffix)
/**
 * Get list that list of files in dir or below that has a given extension. 
 *
 * @param dir is top dir where files with suffix recides  
 * @param suffix is the filter that includes files
 * @return List of File objects
 */
List hasSuffixInOrBelow(String dir,String suffix) {
	List files = new ArrayList();
	walkFileTree(new File(dir),FileVisitor(files,suffix,"item -> { if (item.getName().endsWith(´.´+arg2)) arg1.add(item); return true; }"));
	return files;
} //}}}

//{{{ boolean isNewerOrSolitary(File file,String compareDir, String anotherSuffix)
/**
 * isNewerOrSolitary is used for decision for updating or creating a file with same barename as parameter file, but receding
 * in compareDir and having suffix anotherSuffix
 *
 * @param file to compare
 * @param compareDir of matching file 
 * @param anotherSuffix than that of file 
 * @return true if file is newer or there not exists some matching file in compareDir  
 */
boolean isNewerOrSolitary(File file,String compareDir, String anotherSuffix) {
	return isNewerOrSolitary(file,new File(compareDir,file.getName().replaceAll("\\.\\w+$","."+anotherSuffix)));
} //}}}

//{{{ boolean isNewerOrSolitary(File file,File compareTo)

/**
 * isNewerOrSolitary is used for decision for updating or creating file compareTo
 *
 * @param file to compare
 * @param compareTo of matching file
 * @return true if file is newer than compareTo or compareTo don't exists.
 */
boolean isNewerOrSolitary(File file,File compareTo) {
	return !compareTo.exists() || file.lastModified() > compareTo.lastModified();
} //}}}

//{{{ interface List externCmdOutput(String[] cmds)
/**
 *  Get a list of lines from an extern process
 *
 * @param cmds eg. {"sqlite3","/tmp/myDB.sqlite", "select name from persons"}
 * @return List of lines from extern process
 */
List externCmdOutput(String[] cmds) {
	List lines = new ArrayList();
	Process proc = Runtime.getRuntime().exec(cmds); 
	BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));
	while ((line = br.readLine()) != null) 
		lines.add(line);
	br.close();
	return lines;
} //}}}

//{{{ String atCarretOrSelected(TextArea textArea)
/**
 * Gets word or string from textarea
 * 
 * @param textarea of activeView
 * @return selected string, rightmost word to carret or null
 */
String atCarretOrSelected(TextArea textArea) {
	return atCarretOrSelected(textArea,"\\w+\\b");
} //}}}

//{{{ String atCarretOrSelected(TextArea textArea, String match)
/**
 * Gets word or string from textarea
 * 
 * @param textarea of activeView
 * @param match to select eg. one or several words should be returned
 * @return selected string, rightmost word to carret or null
 */
String atCarretOrSelected(TextArea textArea,String match) {
	String text = textArea.getSelectedText();
	if (null == text) {
		int carretPos = textArea.getCaretPosition();
		textArea.goToEndOfWhiteSpace(true); 
		text = textArea.getSelectedText();
		textArea.setCaretPosition( carretPos,true);
		if (null != text) {
			Matcher m = Pattern.compile(match).matcher(text);
			if (m.find()) 
				text = m.group();
		}
	}
	return text;
} //}}}

//{{{ String unicodeEscaped(String nonEscaped)
/**
 * Convert String to their unicode ecaped representation - it use is to make unambiguous strings to put in code 
 * that otherwise spooks with a compiler.
 *
 * @param nonEscaped is a normal string - eg. "I ♥ jEdit" 
 * @return a unicode escaped sting - eg. "\u0049\u0020\u2665\u0020\u006a\u0045\u0064\u0069\u0074"
 */
String unicodeEscaped(String nonEscaped) {
	backslashUEscaped4digit(String hex) { 
		hex = "000"+hex; 
		return "\\u"+hex.substring(hex.length()-4,hex.length()); 
	}
	String result= "";
	for (int pos=0; pos < nonEscaped.length(); pos++)
		result +=backslashUEscaped4digit(Integer.toUnsignedString((int)nonEscaped.charAt(pos),16)); 
	return "\""+result+"\"";
} //}}}

//{{{ void walkFileTree(File dir, XThis visitor, int maxDepth)
/**
 * Inspired by Files.walkFileTree - traverse a directory recursive
 *
 * @param dir is directory where walking starts
 * @param visitor is a function object that has a method boolean continueVisitFile(File f)
 * @param maxDepth is depth of recursion, -1 is unlimited
 */
void walkFileTree(File dir, XThis visitor, int maxDepth) {
	for (File file: dir.listFiles()) 
		if (file.isDirectory()) { 
			if (maxDepth != 0 )
				walkFileTree(file,visitor,maxDepth-1);
		} else 
			if (!visitor.continueVisitFile(file))
				break;
} //}}}

//{{{ void walkFileTree(File dir, XThis visitor)
/**
 * Inspired by Files.walkFileTree - traverse a directory recursive to unlimited depth
 *
 * @param dir is directory where walking starts
 * @param visitor is a function object that has a method boolean continueVisitFile(File f)
 */
void walkFileTree(File dir, XThis visitor) {
	walkFileTree(dir, visitor,-1);
} //}}}

//{{{ String getClipboard()
/**
 * Gets clipboard textual content, if present
 *
 * @return String clipbord content or null
 */
String getClipboard() {
	java.awt.datatransfer.Transferable tAble = Toolkit.getDefaultToolkit().getSystemClipboard().getContents( null );
	import java.awt.datatransfer.DataFlavor;
	return tAble.isDataFlavorSupported(DataFlavor.stringFlavor)
		? (String)tAble.getTransferData( DataFlavor.stringFlavor )
		: null; 
} //}}}

//{{{ int numLeft2Caret(View view, boolean delete, int defaultOnNoNumber)
/**
 * Get number left to caret
 *
 * @param view of JComponent in use
 * @param delete desides buffer editing behavior
 * @param defaultOnNoNumber return value if no number is found.
 * @return integer left to caret, with any number af spaces between caret and
 * number or defaultOnNoNumber if no number is found. Following happends to buffer
 *	
 *	input										result
 *	---------------------------------------		--------------------
 *	spaces follows number		delete=true		spaces are deleted
 *	no spaces follows number	delete=true		number are deleted
 *	spaces follows number		delete=false	spaces and number is selected
 *	nospaces follows number		delete=false	spaces and number is selected
 */ 
int numLeft2Caret(View view, boolean delete, int defaultOnNoNumber) {
	return numLeft2Caret(view, delete, defaultOnNoNumber, "{1,2}");
} //}}}

//{{{ int numLeft2Caret(View view, boolean delete, int defaultOnNoNumber)
/**
 * Get number left to caret
 *
 * @param view of JComponent in use
 * @param delete desides buffer editing behavior
 * @param defaultOnNoNumber return value if no number is found.
 * @param digitQuantifier regex quantifier to decide number of digits that mathes.
 * @return integer left to caret, with any number af spaces between caret and
 * number or defaultOnNoNumber if no number is found. Following happends to buffer
 *	
 *	input										result
 *	---------------------------------------		--------------------
 *	spaces follows number		delete=true		spaces are deleted
 *	no spaces follows number	delete=true		number are deleted
 *	spaces follows number		delete=false	spaces and number is selected
 *	nospaces follows number		delete=false	spaces and number is selected
 */ 
int numLeft2Caret(View view, boolean delete, int defaultOnNoNumber, String digitQuantifier) {
	TextArea textArea = view.getTextArea();
	int caretLinePos =textArea.getCaretPosition()-textArea.getLineStartOffset(textArea.getCaretLine());
	String toCaret =textArea.getLineText(textArea.getCaretLine()).substring(0,caretLinePos);
	Matcher m=Pattern.compile("\\d"+digitQuantifier+"\\s*$").matcher(toCaret);
	if (m.find())  {
		if (delete)
			textArea.backspaceWord(true);
		else
			for (int i=0; i< m.group().length(); i++)
				textArea.goToPrevCharacter(true);
		return Integer.parseInt( m.group().trim());
	} else
		view.getStatus().setMessage("default: "+ defaultOnNoNumber+" returned");
	return defaultOnNoNumber;

} //}}}

//{{{ List backWordsOrSelected(View view, boolean reverse)
/**
 * Get parameter from current line. In the following the string from start of 
 * caretline to caret is called toCaretLine
 *
 * @param view of JComponent in use.
 * @param reverse makes it possible 'swallow words' from caret moving towards
 * start of line. In that way, words at start of line don't disturb - a function
 * just uses the number of parameters it demands. 
 * @return List with at least two items. Two main categories:
 * 1. With selected text
 * 	Two items - both being the selected text
 * 
 * 2. With no text selected
 * 	  - Words of line, space delimited, becomes items - suitable as reversed.
 * 	  - Delimiting with more than one space is permitted and only count as one.
 * 	  - Double quotes surrounded strings counts as one item and inside such 
 *	    strings no space reduction occurs 
 * 	  - Single quote is just a character
 *
 * @see macro cyberkiss 
 */
List backWordsOrSelected(View view, boolean reverse) {
	return backWordsOrSelected(view, reverse,null);
} //}}}

//{{{ List backWordsOrSelected(View view, boolean reverse,String pattern)
/**
 * Get parameter from current line. In the following the string from start of 
 * caretline to caret is called toCaretLine
 *
 * @param view of JComponent in use.
 * @param reverse makes it possible 'swallow words' from caret moving towards
 * start of line. In that way, words at start of line don't disturb - a function
 * just uses the number of parameters it demands. 
 * @param pattern is used for identication of correct syntax so functions not get 
 * input from lines they shouldn't have being invoked on.
 * @return List with at least two items. Two main categories:
 * 1. With selected text
 * 	Two items - both being the selected text
 * 
 * 2. With no text selected
 * 	Item 0 is toCaretLine
 * 	Item 1 and futher items depends on result of toCaretLine.matches(pattern)
 and whether toCaretline is empty
 * 		false or empty caretLine
 * 			Item1="" - no futher items
 * 		true: 
 * 			- Words of line, space delimited, becomes items - suitable as reversed.
 * 			- Delimiting with more than one space is permitted and only count as one.
 * 			- Double quotes surrounded strings counts as one item and inside such 
 *			  strings no space reduction occurs 
 * 			- Single quote is just a character
 *
 * @see macro cyberkiss 
 */
List backWordsOrSelected(View view, boolean reverse,String pattern) {
	TextArea textArea = view.getTextArea();
	String argText = textArea.getSelectedText();
	List retval;
	if (null == argText) {
		int caretLinePos =textArea.getCaretPosition()-textArea.getLineStartOffset(textArea.getCaretLine());
		argText =textArea.getLineText(textArea.getCaretLine()).substring(0,caretLinePos);
		
		if (pattern==null || argText.matches(pattern)) {
			String line = argText.trim().replace("\t"," ").replaceAll(" +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)"," ");
			retval = new ArrayList(Arrays.asList(line.split(" (?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)")));
			if (reverse)
				Collections.reverse(retval);
		} else
			retval = new ArrayList(asList(""));
	} else
		retval = new ArrayList(asList(argText));
	retval.add(0,argText);
	return retval;
} //}}}

//{{{ String password()
/**
 * Calls password(14) with length default to 14
 *
 * @return password which length is 14.
 */
String password() {
	password(14,false);
} //}}}

//{{{ String password(int length, boolean isHex)
/**
 * Makes a password, using random ASCII values between and inclusive from 33 to 95 
 * The password is also copied to clipboard
 * @param length of password
 * @param isHex if password should be with heximal digits
 * @return password
 */
String password(int length, boolean isHex) {
	String pw="";
	byte[] bytes = new byte[length];
	new java.security.SecureRandom().nextBytes(bytes);
	for (int i=0; i<length; i++) {
		pw += isHex 
		    ? Integer.toString(bytes[i]+128,16)
		    : (char)((bytes[i]+128)%93+33);
	}
	setClip(pw);
	return pw.substring(0,length);
} //}}}

//{{{ String pass32(boolean isHex)
/**
 * 32 chacter long password in which timestamp of creation tine is mangled in.The time can be resolved using timeOfPass32
 *
 * @param ishex decides that that character should belong to 0-9a-f
 * @return password
 
 for future packing

int base = (255*Math.random()).intValue();
int sec = (255*Math.random()).intValue();
int app = base ^ sec;

p(new int[]{ base,sec,app,base ^ app } ); 

 **/

String pass32(boolean isHex) {
    String hexUnixtime = Long.toString(System.currentTimeMillis()/1000L,16);
    StringBuilder combined = new StringBuilder();
    String h32 = password(32,isHex);
    for (int i=0; i< 8; i++)
        combined.append(hexUnixtime.substring(i,i+1)).append(h32.substring(4*i+1,4*(i+1)));
    setClip(combined.toString());
    return combined.toString();
} //}}}

//{{{ Date timeOfPass32(String pass) 
/**
 * Resolves in mangled timestamp of password
 *
 * @param pass is password, which timestamp has to be resolved
 * @return timestamp as Date object
 **/
Date timeOfPass32(String pass) {
    long l, hVal;
    for (int i=0; i<8; i++) {
        hVal = (int)pass.charAt(i*4);
        l = l*16  + (hVal < 58 ? hVal- 48 : hVal - 87);
    }
    return new Date(1000*l);
} //}}}

//{{{ String base32RndStr(int length)
/**
 * base 32 string af random numbers
 *
 * @param length of string
 * @return base 32 string af random numbers
 **/
String base32RndStr(int length) {
    String pw="";
    byte[] bytes = new byte[length];
	new java.security.SecureRandom().nextBytes(bytes);
	for (int i=0; i<length; i++) 
		pw += Integer.toString(bytes[i]&31,32);
	setClip(pw);
	return pw;
} //}}}

//{{{ setClip(String clip)
/**
 * Puts a clip in clipboard
 *
 * @param clip to be putted in clipboard
 */
void setClip(String clip) {
	Registers.getRegister('$').setTransferable(new java.awt.datatransfer.StringSelection(clip));
} //}}}

//{{{ List asciiTable()
/**
 * Ascii table
 *
 * @return list of lines of table with ascii values from 32-255
 */
List asciiTable() {
	String spaces(int len) {
		return new String(new char[len]).replace('\0',' ');
	}
    List lines = new ArrayList();
    int spaceLen=2;
    String line="    ";
    for (String colHead : new String[]{ "0 ","4 ","8 ","c ","10","14","18","1c"})
        line += colHead+spaces(spaceLen+2);
    lines.add(line);
    int lineLen=32;
    for (int lineBeg = 32; lineBeg < 255; lineBeg +=lineLen) {
        line = Integer.toString(lineBeg,16)+"  ";
        for ( int chr = lineBeg; chr < lineBeg+lineLen; chr++) {
            line += (char)chr;
            if (chr % 4 == 3)
                line += spaces(spaceLen);
        }
        lines.add(line.toString());
    }
    return lines;
} //}}}

//{{{ void showStat(View view,String mes)
/**
 * shows, execution asserted at time 'prg' in status line 
 *
 * @param view is a needed JComponent context 
 * @param mes is the chown message
 */
void showStat(View view,String mes) {
    view.getStatus().setMessage(mes);
} //}}}

//{{{ String now()
/**
 * Return current time of day in 24hour hh:mm:ss format
 *
 * @return current time of day in 24hour hh:mm:ss format 
 */
String now() {
	return now("H:mm:ss");
} //}}}

//{{{ String now(String format)
/**
 * Returns current timestamp
 *
 * @param format of time appearence
 * @return current formatted timestamp.
 */
String now(String format) {
	return java.time.LocalTime.now().format(java.time.format.DateTimeFormatter.ofPattern(format)).toString();
} //}}}

//{{{ void iconifyAfter(int xMillis)
/**
 * Iconify jEdit after xMillis milliseconds
 *
 * @param xMillis is the sleeptime in milliseconds before jEdit is iconified.
 */
void iconifyAfter(int xMillis) {
    threadObj() {
        void run() {
            Thread.currentThread().sleep(xMillis);
            jEdit.getActiveView().setState(Frame.ICONIFIED);
        }
        return this;
    }
    new Thread(threadObj()).start();
} //}}}

//{{{ void pa(Object egg) 
/**
 * This, as ... filtered best used, activity log print chicken, is the naken system bootstrap for writting a print utiliy. 
 */
public void pa(Object egg) { print("..."+egg); 
} //}}}
