/**
 * Demonstrate unveiling of permittedAS EditActions actions, by showing pattern surrounded code snippets followed by the result
* of its execution as they could have been expressed in action.xml syntax.
 *
 * @library pageheading
 * @plugin home.txtconv.TxtConvPlugin (using com.github.rjeschke.txtmark.*, org.jsoup.*) 
 */
	
Runnable page() {
	
	void run() {
		StringBuilder fLines = pageheading(scriptPath, "// startPattern", "// endPattern",
			 "<!-- head=siteJedit.css.html+adjustmargin.css+jquery.html+prettify.html+prettyClassify.js+sitePages()+eventsAndNav.js & "
			+"body=pageJEdit.md & title=Magic+Ownnamespace -->\n### Magic ownnamespace of BeanShell.runScript(...)\n\n","");
	// startPattern
	String simpleName(String className) {
		return className.matches(".+?\\[Ljava.+") 
			? "String[]" 
			:className.replaceAll("class ","").replaceAll("(\\w+\\.)+","");
	}
	TreeMap methods = new TreeMap();
	for (org.gjt.sp.jedit.bsh.BshMethod m:BeanShell.getNameSpace().getMethods()) {
		String parms="";
		if (m.getParameterTypes().length >0) {
			String [] parmA = new String[m.getParameterTypes().length];
			
			int i=0;
			for (Class claz: m.getParameterTypes())  {
				parmA[i++]= (claz==null? "uknown" : claz.getSimpleName());
			}
		
			i=0;
			for (s: m.getParameterNames())
				if (null != s && i < parmA.length) {
					parmA[i]=parmA[i] +" "+s;
					i++;
				}
			parms=String.join(",",parmA);
		}
		if (null != m.getReturnType())
			methods.put(simpleName(""+m.getReturnType())+" "+m.getName(),"("+parms+")");
	}
	fLines.append("\n---\n");
	for (String method : methods.keySet()) 
		fLines.append("\t").append(method).append(methods.get(method)).append("\n");
	
	// endPattern
	
		toFile(scriptPath.replaceAll("\\.\\w+$",".md"),fLines.append("\n").toString());
		//pt("saved "+scriptPath.replaceAll("\\.\\w+$",".md"));
	}
	return this;
}

new Thread(page()).start();
